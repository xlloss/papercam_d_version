/**
 @file mmpf_jstream.c
 @brief Control functions of JPEG Streamer
 @author Alterman
 @version 1.0
*/

#include "includes_fw.h"
#include "mmph_hif.h"

#include "mmpf_system.h"
#include "mmpf_sensor.h"
#include "mmpf_dma.h"
#include "mmpf_dsc.h"
#include "mmpf_jstream.h"
//#include "ex_misc.h"


/** @addtogroup MMPF_JSTREAM
@{
*/
//==============================================================================
//
//                              VARIABLES
//
//==============================================================================
/*
 * Local Variables
 */
static MMPF_JSTREAM_CLASS   m_JStreamObj[MAX_JPG_STREAM_NUM];

static MMPF_OS_SEMID        m_JDmaSemID;

static MMPF_OS_SEMID        m_JEncSemID;//for thumb

/*
 * External Variables
 */
extern MMPF_OS_FLAGID       DSC_Flag;

//==============================================================================
//
//                              MACRO FUNCTIONS
//
//==============================================================================

#define JSTREAM_OBJ(id)     (&m_JStreamObj[id])
#define JSTREAM_ID(obj)     (obj - &m_JStreamObj[0])

//==============================================================================
//
//                              FUNCTION PROTOTYPES
//
//==============================================================================

static void MMPF_JStream_Reset(MMPF_JSTREAM_CLASS *jobj);
static MMP_ERR MMPF_JStream_PopFrameInfo(   MMPF_JSTREAM_CLASS  *jobj,
                                            MMP_ULONG           *addr,
                                            MMP_ULONG           *size,
                                            MMP_ULONG           *time);
#if (V4L2_JPG)
extern MMP_BOOL aitcam_ipc_send_frame(  MMP_ULONG   v4l2_id,
                                        MMP_ULONG   size,
                                        MMP_ULONG   ts);
extern MMP_ULONG aitcam_ipc_get_slot(    MMP_ULONG   v4l2_id,
                                        MMP_ULONG   *slot);
#endif

//==============================================================================
//
//                              FUNCTION DEFINITION
//
//==============================================================================

#if 0
void _____JSTREAM_PUBLIC_INTERFACE_____(){}
#endif

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_New
//  Description :
//------------------------------------------------------------------------------
/**
 @brief New a JPEG streamer

 @retval Id of the new jstream.
*/
MMP_ULONG MMPF_JStream_New(void)
{
    MMP_ULONG i;
    MMPF_JSTREAM_CLASS *jobj = NULL;

    for(i = 0; i < MAX_JPG_STREAM_NUM; i++) {
        if (m_JStreamObj[i].state == JSTREAM_STATE_NONE) {
            jobj = &m_JStreamObj[i];
            jobj->state = JSTREAM_STATE_OPEN;
            break;
        }
    }

    if (!jobj) {
        RTNA_DBG_Str(0, "JStream no obj\r\n");
        return MAX_JPG_STREAM_NUM;
    }

    return JSTREAM_ID(jobj);
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_Delete
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Release the JPEG streamer

 @param[in] id      Id of jstream object

 @retval None.
*/
void MMPF_JStream_Delete(MMP_ULONG id)
{
    MMPF_JSTREAM_CLASS *jobj = JSTREAM_OBJ(id);

    if (jobj->state != JSTREAM_STATE_OPEN) {
        RTNA_DBG_Str0("Stop jstream first!\r\n");
    }

    MMPF_JStream_Reset(JSTREAM_OBJ(id));
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_Start
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Start streaming the specified JStream object

 @param[in] id      JStream object ID
 @param[in] v4l2_id Corresponded V4L2 stream id
 @param[in] opt     Option of streaming

 @retval None.
*/
MMP_ERR MMPF_JStream_Start( MMP_ULONG           id,
                            MMP_ULONG           v4l2_id,
                            IPC_STREAMER_OPTION opt)
{
    MMPF_JSTREAM_CLASS *jobj = JSTREAM_OBJ(id);

    if (jobj->state != JSTREAM_STATE_OPEN)
        return MMP_JSTREAM_ERR_STATE;
    printc("%s stream id (v4l2_id) %d\r\n", __func__, v4l2_id);
    jobj->opt       = opt;
    jobj->v4l2_id   = v4l2_id;
    jobj->state     = JSTREAM_STATE_START;
    MMPF_OS_SetFlags(STREAMER_Flag, SYS_FLAG_JSTREAM(id), MMPF_OS_FLAG_SET);

    return MMP_ERR_NONE;
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_Stop
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Stop streaming the specified JStream object

 @param[in] id      JStream object ID

 @retval None.
*/
MMP_ERR MMPF_JStream_Stop(MMP_ULONG id)
{
    MMPF_JSTREAM_CLASS *jobj = JSTREAM_OBJ(id);

    if (jobj->state != JSTREAM_STATE_START)
        return MMP_JSTREAM_ERR_STATE;

    jobj->state = JSTREAM_STATE_OPEN;

    return MMP_ERR_NONE;
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_TriggerEncode
//  Description : 
//------------------------------------------------------------------------------
/**
 @brief Tigger JPEG encode

 @param[in] id      JStream object ID

 @retval None.
*/
void MMPF_JStream_TriggerEncode(MMP_ULONG id)
{
    MMPF_OS_SetFlags(DSC_Flag, DSC_FLAG_TRIGGER_STILL, MMPF_OS_FLAG_SET);
}

//add sem for thumb
void MMPF_JStream_AcqEncSem()
{
    if (MMPF_OS_AcquireSem(m_JEncSemID, 10000)) {
        RTNA_DBG_Str0("m_JEncSemPend fail\r\n");
        return;
    }
}



MMP_ERR MMPF_JStream_GetFrame(MMP_ULONG id,MMP_ULONG *jpg_addr , MMP_ULONG *jpg_size)
{
    MMPF_JSTREAM_CLASS *jobj = JSTREAM_OBJ(id);
    MMP_ULONG available, addr, size, time;

    *jpg_addr = 0 ;
    *jpg_size = 0 ;
    if( ! jobj) {
        return  MMP_JSTREAM_ERR_NODATA ;   
    }    
    AUTL_RingBuf_DataAvailable(&jobj->info_q.ring, &available);
    if (available == 0) {
        return MMP_JSTREAM_ERR_NODATA;
    }
    MMPF_JStream_PopFrameInfo(jobj, &addr, &size, &time);
    *jpg_addr = addr ;
    *jpg_size = size ;

    return MMP_ERR_NONE ;
}


#if 0
void _____JSTREAM_INTERNAL_FUNC_____(){}
#endif

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_PushFrameInfo
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Save the frame info. into the queue.

 @param[in] id      JStream object ID
 @param[in] addr    Encoded frame data address
 @param[in] size    Encoded frame size
 @param[in] time    Encoded frame timestamp

 @retval It reports the status of the operation.
*/
static MMP_ERR MMPF_JStream_PushFrameInfo(  MMP_ULONG               id,
                                            MMPF_JSTREAM_FRAMEINFO  *info)
{
    MMP_ULONG free;
    MMPF_JSTREAM_CLASS *jobj = JSTREAM_OBJ(id);
    MMPF_JSTREAM_FRAMEINFO  *pInfo = NULL;

    AUTL_RingBuf_SpaceAvailable(&jobj->info_q.ring, &free);
    if (free >= 1) {
        pInfo = &jobj->info_q.data[jobj->info_q.ring.ptr.wr];
        pInfo->addr = info->addr;
        pInfo->size = info->size;
        pInfo->time = info->time;
        printc("%s info->addr 0x%x\r\n", __func__, info->addr);
        printc("%s info->size %d\r\n", __func__, info->size);
        AUTL_RingBuf_CommitWrite(&jobj->info_q.ring, 1);
    }
    else {
#if SUPPORT_UVC_JPEG==0
        RTNA_DBG_Str0("No space for frame info\r\n");
#endif
        return MMP_JSTREAM_ERR_OVERFLOW;
    }

    return MMP_ERR_NONE;
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_PopFrameInfo
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Read out the frame info. into the queue.

 @param[in] jobj    JStream object
 @param[out] addr   Encoded frame data address
 @param[out] size   Encoded frame size
 @param[out] time   Encoded frame timestamp

 @retval It reports the status of the operation.
*/
static MMP_ERR MMPF_JStream_PopFrameInfo(   MMPF_JSTREAM_CLASS  *jobj,
                                            MMP_ULONG           *addr,
                                            MMP_ULONG           *size,
                                            MMP_ULONG           *time)
{
    MMP_ULONG available;
    MMPF_JSTREAM_FRAMEINFO  *pInfo = NULL;

    AUTL_RingBuf_DataAvailable(&jobj->info_q.ring, &available);
    if (available >= 1) {
        pInfo = &jobj->info_q.data[jobj->info_q.ring.ptr.rd];
        *addr = pInfo->addr;
        *size = pInfo->size;
        *time = pInfo->time;
        AUTL_RingBuf_CommitRead(&jobj->info_q.ring, 1);
    }
    else {
        RTNA_DBG_Str0("No available frame info\r\n");
        return MMP_JSTREAM_ERR_UNDERFLOW;
    }

    return MMP_ERR_NONE;
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_ReleaseDma
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Callback function to release DMA semaphore.

 @param[in] argu    Callback argument, no used

 @retval None.
*/
static void MMPF_JStream_ReleaseDma(void *argu)
{
	if (MMPF_OS_ReleaseSem(m_JDmaSemID) != OS_NO_ERR) {
		RTNA_DBG_Str0("m_JDmaSemID OSSemPost: Fail\r\n");
	}
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_DmaMoveData
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Copy JPEG data to another buffer by move DMA.

 @param[in] src     Source address of data
 @param[in] dst     Destination address
 @param[in] sz      Data size

 @retval None.
*/
static void MMPF_JStream_DmaMoveData(MMP_ULONG src, MMP_ULONG dst, MMP_ULONG sz)
{
    if (sz == 0)
        return;

	if (MMPF_DMA_MoveData(src, dst, sz, MMPF_JStream_ReleaseDma,
	                      0, MMP_FALSE, NULL))
    {
        RTNA_DBG_Str0("MoveData fail\r\n");
        return;
	}
	if (MMPF_OS_AcquireSem(m_JDmaSemID, 10000)) {
        RTNA_DBG_Str0("m_JDmaSemPend fail\r\n");
        return;
	}
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_TransferFrame
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Transfer frames via V4L2 interface

 @param[in] jobj    JStream object

 @retval None.
*/
static MMP_ERR MMPF_JStream_TransferFrame(MMPF_JSTREAM_CLASS *jobj)
{
    MMP_ULONG available = 0, addr, size1 = 0, size2 = 0, time = 0;
    MMP_ULONG freesize ;
    MMP_ULONG id, slotbuf;

    if (jobj->state != JSTREAM_STATE_START)
        return MMP_JSTREAM_ERR_NODATA;

    if (jobj->opt & IPC_STREAMER_OPT_FLUSH) {
        AUTL_RingBuf_Flush(&jobj->info_q.ring);
        jobj->opt &= ~(IPC_STREAMER_OPT_FLUSH);
    }

    AUTL_RingBuf_DataAvailable(&jobj->info_q.ring, &available);
    if (available == 0)
        return MMP_JSTREAM_ERR_NODATA;

    id = JSTREAM_ID(jobj);
    printc("%s slotbuf %d\r\n", __func__, slotbuf);
    freesize = aitcam_ipc_get_slot(jobj->v4l2_id, &slotbuf);
    if (freesize) {
        printc("slot_freesize\r\n");

        MMPF_JStream_PopFrameInfo(jobj, &addr, &size1, &time);
        printc("%s->1 addr 0x%x\r\n", __func__, addr);
        printc("%s->1 size1 %d\r\n", __func__, size1);
        MMPF_JStream_DmaMoveData(addr, slotbuf, size1);

        MMPF_JStream_PopFrameInfo(jobj, &addr, &size2, &time);
        printc("%s->2 addr 0x%x\r\n", __func__, addr);
        printc("%s->2 size2 %d\r\n", __func__, size2);
        MMPF_JStream_DmaMoveData(addr, slotbuf + size1, size2);

        aitcam_ipc_send_frame(jobj->v4l2_id, size1 + size2, time);
    }
    else {
        //RTNA_DBG_Str(0, "J++\r\n");
    }

    return MMP_ERR_NONE;
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_TransferData
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Transfer the JPEG data

 @param[in] id      JStream object ID

 @retval None.
*/
void MMPF_JStream_TransferData(MMP_ULONG id)
{
    MMP_ULONG   times = 5;
    MMP_ERR     status;

    while(times--) {
        // move JPEG data from bitstream buffer to V4L2 slot buffers
        status = MMPF_JStream_TransferFrame(JSTREAM_OBJ(id));
        if (status != MMP_ERR_NONE)
            break;
    }
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_Reset
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Reset the JStream object.

 @param[in] jobj    JStream object

 @retval None.
*/
static void MMPF_JStream_Reset(MMPF_JSTREAM_CLASS *jobj)
{
    /* Reset JStream state & properties */
    jobj->state = JSTREAM_STATE_NONE;
    AUTL_RingBuf_Init(&jobj->info_q.ring, (MMP_ULONG)jobj->info_q.data,
                                          JSTREAM_INFO_Q_DEPTH);
}

//------------------------------------------------------------------------------
//  Function    : MMPF_JStream_TaksInit
//  Description :
//------------------------------------------------------------------------------
/**
 @brief Initialize routine in AStream task startup.

 @retval None.
*/
static void MMPF_JStream_TaksInit(void)
{
    MMP_ULONG i;

    m_JDmaSemID = MMPF_OS_CreateSem(0);
	m_JEncSemID = MMPF_OS_CreateSem(0);//add for thumb

    /* Reset all JStream objects */
    for(i = 0; i < MAX_JPG_STREAM_NUM; i++)
        MMPF_JStream_Reset(JSTREAM_OBJ(i));
}

#if 0
void _____JSTREAM_TASK_ROUTINES_____(){}
#endif

MMP_UBYTE exif_1[] = {
	0xff, 0xd8, 0xff, 0xe1, 0x01, 0x72, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d, 0x00, 0x2a,
	0x00, 0x00, 0x00, 0x08, 0x00, 0x07, 0x01, 0x0f, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00,
	0x00, 0x62, 0x01, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x6e, 0x01, 0x1a,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7e, 0x01, 0x1b, 0x00, 0x05, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x86, 0x01, 0x28, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02,
	0x00, 0x00, 0x02, 0x13, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x87, 0x69,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x50, 0x41,
	0x50, 0x45, 0x52, 0x20, 0x53, 0x48, 0x4f, 0x4f, 0x54, 0x00, 0x50, 0x41, 0x50, 0x45, 0x52, 0x20,
	0x53, 0x48, 0x4f, 0x4f, 0x54, 0x2d, 0xe2, 0x85, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0c, 0x82, 0x9a, 0x00, 0x05,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x24, 0x82, 0x9d, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x01, 0x2c, 0x88, 0x27, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x64, 0x00, 0x00,
	0x90, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x04, 0x30, 0x32, 0x33, 0x30, 0x90, 0x03, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x01, 0x34, 0x91, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x04,
	0x01, 0x02, 0x03, 0x00, 0x92, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x52,
	0x92, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x5a, 0x92, 0x07, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x00, 0x00, 0x92, 0x0a, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x01, 0x62, 0xa0, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x04, 0x30, 0x31, 0x30, 0x30,
	0xa0, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x05,
	0x32, 0x30, 0x39, 0x39, 0x3a, 0x31, 0x32, 0x3a, 0x33, 0x31, 0x20, 0x31, 0x32, 0x3a, 0x30, 0x30,
	0x3a, 0x30, 0x30, 0x2e, 0x30, 0x30, 0x2d, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x5f, 0x29, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 
	// thumbnail header
	0x00, 0x06, 0x01, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01,	0x00, 0x06, 0x00, 0x00, 0x01, 0x1a,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xb8,	0x01, 0x1b, 0x00, 0x05, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x01, 0xc0, 0x01, 0x28, 0x00, 0x03,	0x00, 0x00, 0x00, 0x01, 0x00, 0x02,
	0x00, 0x00, 0x02, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01,	0x00, 0x00, 0x01, 0xc8, 0x02, 0x02,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a, 0x12,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48,	0x00, 0x00, 0x00, 0x01,	0xff, 0xd8,
	0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,	0x01, 0x01, 0x00, 0x48, 0x00, 0x48,
	0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x06, 0x04, 0x05,	0x06, 0x05, 0x04, 0x06, 0x06, 0x05,
	0x06, 0x07, 0x07, 0x06, 0x08, 0x0a, 0x10, 0x0a, 0x0a, 0x09,	0x09, 0x0a, 0x14, 0x0e, 0x0f, 0x0c,
	0x10, 0x17, 0x14, 0x18, 0x18, 0x17, 0x14, 0x16, 0x16, 0x1a,	0x1d, 0x25, 0x1f, 0x1a, 0x1b, 0x23,
	0x1c, 0x16, 0x16, 0x20, 0x2c, 0x20, 0x23, 0x26, 0x27, 0x29,	0x2a, 0x29, 0x19, 0x1f, 0x2d, 0x30,
	0x2d, 0x28, 0x30, 0x25, 0x28, 0x29, 0x28,
};

MMP_UBYTE thumbnail[100*1024];
	
MMP_UBYTE exif_2[] = {
	0xff, 0xe1, 0x0c, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,	0x2f, 0x6e, 0x73, 0x2e, 0x61, 0x64,
	0x6f, 0x62, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x78, 0x61,	0x70, 0x2f, 0x31, 0x2e, 0x30, 0x2f,
	0x00, 0x3c, 0x3f, 0x78, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,	0x20, 0x62, 0x65, 0x67, 0x69, 0x6e,
	0x3d, 0x27, 0xef, 0xbb, 0xbf, 0x27, 0x20, 0x69, 0x64, 0x3d,	0x27, 0x57, 0x35, 0x4d, 0x30, 0x4d, 
	0x70, 0x43, 0x65, 0x68, 0x69, 0x48, 0x7a, 0x72, 0x65, 0x53,	0x7a, 0x4e, 0x54, 0x63, 0x7a, 0x6b,
	0x63, 0x39, 0x64, 0x27, 0x3f, 0x3e, 0x0a, 0x3c, 0x78, 0x3a,	0x78, 0x6d, 0x70, 0x6d, 0x65, 0x74,
    0x61, 0x20, 0x78, 0x6d, 0x6c, 0x6e, 0x73, 0x3a, 0x78, 0x3d,	0x27, 0x61, 0x64, 0x6f, 0x62, 0x65,
	0x3a, 0x6e, 0x73, 0x3a, 0x6d, 0x65, 0x74, 0x61, 0x2f, 0x27,	0x20, 0x78, 0x3a, 0x78, 0x6d, 0x70,
    0x74, 0x6b, 0x3d, 0x27, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x3a,	0x3a, 0x45, 0x78, 0x69, 0x66, 0x54, 
    0x6f, 0x6f, 0x6c, 0x20, 0x39, 0x2e, 0x34, 0x36, 0x27, 0x3e,	0x0a, 0x3c, 0x72, 0x64, 0x66, 0x3a,
    0x52, 0x44, 0x46, 0x20, 0x78, 0x6d, 0x6c, 0x6e, 0x73, 0x3a,	0x72, 0x64, 0x66, 0x3d, 0x27, 0x68,
    0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e,	0x77, 0x33, 0x2e, 0x6f, 0x72, 0x67,
    0x2f, 0x31, 0x39, 0x39, 0x39, 0x2f, 0x30, 0x32, 0x2f, 0x32,	0x32, 0x2d, 0x72, 0x64, 0x66, 0x2d,
    0x73, 0x79, 0x6e, 0x74, 0x61, 0x78, 0x2d, 0x6e, 0x73, 0x23,	0x27, 0x3e, 0x0a, 0x0a, 0x20, 0x3c,
    0x72, 0x64, 0x66, 0x3a, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x72, 0x64, 0x66, 0x3a, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x3d,	0x27, 0x27, 0x0a, 0x20, 0x20, 0x78,
    0x6d, 0x6c, 0x6e, 0x73, 0x3a, 0x65, 0x78, 0x69, 0x66, 0x3d,	0x27, 0x68, 0x74, 0x74, 0x70, 0x3a,
    0x2f, 0x2f, 0x6e, 0x73, 0x2e, 0x61, 0x64, 0x6f, 0x62, 0x65,	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x65,
    0x78, 0x69, 0x66, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x27, 0x3e,	0x0a, 0x20, 0x20, 0x3c, 0x65, 0x78,
    0x69, 0x66, 0x3a, 0x44, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6d,	0x65, 0x4f, 0x72, 0x69, 0x67, 0x69,
    0x6e, 0x61, 0x6c, 0x3e, 0x32, 0x30, 0x39, 0x39, 0x2d, 0x31,	0x32, 0x2d, 0x33, 0x31, 0x54, 0x31,
    0x32, 0x3a, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x2e, 0x30, 0x30,	0x2d, 0x30, 0x30, 0x3a, 0x30, 0x30,
    0x3c, 0x2f, 0x65, 0x78, 0x69, 0x66, 0x3a, 0x44, 0x61, 0x74,	0x65, 0x54, 0x69, 0x6d, 0x65, 0x4f,
    0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x3e, 0x0a, 0x20,	0x20, 0x3c, 0x65, 0x78, 0x69, 0x66,
    0x3a, 0x46, 0x6c, 0x61, 0x73, 0x68, 0x20, 0x72, 0x64, 0x66,	0x3a, 0x70, 0x61, 0x72, 0x73, 0x65,
    0x54, 0x79, 0x70, 0x65, 0x3d, 0x27, 0x52, 0x65, 0x73, 0x6f,	0x75, 0x72, 0x63, 0x65, 0x27, 0x3e,
    0x0a, 0x20, 0x20, 0x20, 0x3c, 0x65, 0x78, 0x69, 0x66, 0x3a,	0x46, 0x69, 0x72, 0x65, 0x64, 0x3e,
    0x46, 0x61, 0x6c, 0x73, 0x65, 0x3c, 0x2f, 0x65, 0x78, 0x69,	0x66, 0x3a, 0x46, 0x69, 0x72, 0x65,
    0x64, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x3c, 0x65, 0x78, 0x69,	0x66, 0x3a, 0x46, 0x75, 0x6e, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x3e, 0x46, 0x61, 0x6c, 0x73, 0x65,	0x3c, 0x2f, 0x65, 0x78, 0x69, 0x66,
    0x3a, 0x46, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x3e,	0x0a, 0x20, 0x20, 0x20, 0x3c, 0x65,
    0x78, 0x69, 0x66, 0x3a, 0x4d, 0x6f, 0x64, 0x65, 0x3e, 0x32,	0x3c, 0x2f, 0x65, 0x78, 0x69, 0x66,
    0x3a, 0x4d, 0x6f, 0x64, 0x65, 0x3e, 0x0a, 0x20, 0x20, 0x20,	0x3c, 0x65, 0x78, 0x69, 0x66, 0x3a,
    0x52, 0x65, 0x64, 0x45, 0x79, 0x65, 0x4d, 0x6f, 0x64, 0x65,	0x3e, 0x46, 0x61, 0x6c, 0x73, 0x65,
    0x3c, 0x2f, 0x65, 0x78, 0x69, 0x66, 0x3a, 0x52, 0x65, 0x64,	0x45, 0x79, 0x65, 0x4d, 0x6f, 0x64,
    0x65, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x3c, 0x65, 0x78, 0x69,	0x66, 0x3a, 0x52, 0x65, 0x74, 0x75,
    0x72, 0x6e, 0x3e, 0x30, 0x3c, 0x2f, 0x65, 0x78, 0x69, 0x66,	0x3a, 0x52, 0x65, 0x74, 0x75, 0x72,
    0x6e, 0x3e, 0x0a, 0x20, 0x20, 0x3c, 0x2f, 0x65, 0x78, 0x69,	0x66, 0x3a, 0x46, 0x6c, 0x61, 0x73,
    0x68, 0x3e, 0x0a, 0x20, 0x3c, 0x2f, 0x72, 0x64, 0x66, 0x3a,	0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3e, 0x0a, 0x3c, 0x2f, 0x72,	0x64, 0x66, 0x3a, 0x52, 0x44, 0x46,
    0x3e, 0x0a, 0x3c, 0x2f, 0x78, 0x3a, 0x78, 0x6d, 0x70, 0x6d,	0x65, 0x74, 0x61, 0x3e, 0x0a,
};

MMP_UBYTE exif_3[] = {
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x0a,
};

MMP_UBYTE exif_4[] = {
	0x3c, 0x3f, 0x78, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x65, 0x6e, 0x64, 0x3d, 0x27, 0x77,
	0x27, 0x3f, 0x3e,
};

/*
static void dump_ram(MMP_UBYTE *data, MMP_ULONG cnt)
{
	MMP_ULONG i;
	
	for (i = 0; i < cnt; i++) {
		RTNA_DBG_Byte(0, data[i]);
    }
	RTNA_DBG_Str(0, "\r\n");
}

static void dump_ram_info(MMP_UBYTE *data, MMP_ULONG cnt)
{
    RTNA_DBG_Byte(0, data[cnt]);
    RTNA_DBG_Str(0, "\r\n");
}
*/
/*//chrison
static void set_ram_info(MMP_UBYTE *data, MMP_USHORT value, MMP_ULONG cnt)
{
	data[cnt] = value&0xff;
	data[cnt-1] = value>>8;
}
*/
extern MMP_BOOL encode_done;
extern MMP_ULONG thumbnail_size;
extern MMP_ULONG header_size;
/**
 @brief Main routine of JStream task.
*/
void MMPF_JStream_Task(void)
{
	static MMP_BOOL id = 0;
	static MMP_BOOL once = 1;
    MMPF_OS_FLAGS wait_flags = 0, flags;
    MMPF_JSTREAM_FRAMEINFO frminfo;
	
	MMP_ULONG ulExpTime;
	MMP_ULONG ulIso;
	MMP_USHORT exif_cnt;
	MMP_USHORT value;
	
    RTNA_DBG_Str3("JStream_Task()\r\n");

    MMPF_JStream_TaksInit();

    wait_flags = DSC_FLAG_TRIGGER_STILL;

    while(1) {
        MMPF_OS_WaitFlags(  DSC_Flag, wait_flags,
                            MMPF_OS_FLAG_WAIT_SET_ANY | MMPF_OS_FLAG_CONSUME,
                            0, &flags);
        if (flags & DSC_FLAG_TRIGGER_STILL) {

			if (encode_done == 0) {
				MMPF_Sensor_Wait3AConverge(PRM_SENSOR);
				MMPF_ISP_GetExposureTime(&ulExpTime);
				MMPF_ISP_GetISOSpeed(&ulIso);
				printc("\r\n==========ulIso %d ulExpTime %d \r\n", ulIso, ulExpTime);
			}
			printc("==========%s %d %d\r\n", __func__, __LINE__, OSTime);
			MMPF_DSC_EncodeJpeg(PRM_SENSOR, MMPF_DSC_SRC_SENSOR,
                                MMPF_DSC_SHOTMODE_SINGLE);
            MMPF_DSC_GetJpeg(&frminfo.addr, &frminfo.size, &frminfo.time);
            printc("==========%s id %d frminfo.addr %d\r\n", __func__, id, frminfo.addr);
            printc("==========%s id %d frminfo.size %d\r\n", __func__, id, frminfo.size);
			MMPF_JStream_PushFrameInfo(id, &frminfo);
			MMPF_OS_SetFlags(STREAMER_Flag, SYS_FLAG_JSTREAM(id), MMPF_OS_FLAG_SET);
			MMPF_SYS_DumpTimerMark();
//				if (OSTime < KEEP_LED_2ND) {
//					if (id) {
//						MMPF_OS_Sleep_MS(KEEP_LED_2ND-OSTime);
//					} else {
//						if (OSTime < KEEP_LED_1ST) {
//							MMPF_OS_Sleep(KEEP_LED_1ST-OSTime);
//						}
//					}
//					printc("==========%s %d %d \r\n", __func__, __LINE__, OSTime);
//				}
//				if (power_off == 0) { 
//					LED_Off(LED_R);
//				}
				encode_done = 1;//add by chrison
			//}//add by chrison
            #if SUPPORT_UVC_JPEG==1
            {
              MMPF_JSTREAM_CLASS *jobj = JSTREAM_OBJ(0);
              if(jobj->state==JSTREAM_STATE_START) {
                MMPF_JStream_TriggerEncode(0) ;
              }
            }
            #endif
			printc("##encode thumb done\r\n");//triger for thumb
            if (MMPF_OS_ReleaseSem(m_JEncSemID) != OS_NO_ERR) {
               RTNA_DBG_Str0("m_JEncSemID OSSemPost: Fail\r\n");
            }

        }
    }
}

/// @}
